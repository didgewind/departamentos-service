Eureka, mongodb, hystrix, no sec, no config server, credenciales de acceso a empleados cableadas

Servicio REST con departamentos y empleados en cada departamento. En esta rama tenemos acceso a la bd, 
y recuperamos los empleados de cada departamento cuando se nos piden los departamentos a través del 
servicio de empleados. Cableamos para ello las credenciales profe - profe.

Ésta es la rama para pruebas Saga y CQRS. Ahora mismo procesamos EmpleadosEvents con la clase
EmpleadosEventsListener para los tipos de evento CREATE y DELETE, que provocan respectivamente
una asociación nueva en la bd (del empleado creado al dpto
indicado en el evento) y una eliminación de esa asociación. Además hemos refactorizado
el SagaEventsProducer para que sea más user friendly.

Todo esto lo configuramos entre el .yml, el negocio y el paquete Saga
(usando un KafkaTemplate y un SagaEventsListener).

Para que funcione todo previamente necesitamos lanzar kafka y crear el topic (con las tres particiones)
con los siguientes comandos (desde el folder kafka, en mi caso ~/applications/kafka_2.13-2.8.0):

	bin/zookeeper-server-start.sh -daemon config/zookeeper.properties

	bin/kafka-server-start.sh -daemon config/server.properties
	
	bin/kafka-topics.sh --create --topic empleados-events --replication-factor 1 \
    --partitions 3 --bootstrap-server localhost:9092

	bin/kafka-topics.sh --create --topic saga-control-events --replication-factor 1 \
    --partitions 3 --bootstrap-server localhost:9092
    
Podemos probar que el servicio de empleados (y el de departamentos) están enviando / recibiendo
datos lanzando un par de consumidores de esta manera:

	bin/kafka-console-consumer.sh --topic empleados-events --from-beginning --bootstrap-server localhost:9092
	
para lanzar el consumidor de eventos del servicio de departamentos ejecutar el mismo comando
sustituyendo empleados-events por saga-control-events

Tenemos dos daos, uno tira de una bd mysql con JdbcTemplate y la otra de mongodb con MongoRepository.

La bd mysql consta de una tabla de departamentos y otra que relaciona empleados con departamentos. 
Para que la bd esté consistente hay que lanzar los scripts de creación de empleados_simple
y de departamentos. Un
empleado puede pertenecer a 0 o varios departamentos. La idea es poder probar transacciones
distribuidas en microservicios eliminando un empleado y fallando al eliminar los registros
de ese empleado en empleados_departamentos.

La bd mongo consta de una colección departamentos con un documento departamentos. Los empleados
de cada departamento están representados en este documento sólo con el cif. La clase de negocio
es la misma para los dos Daos aunque se podría optimizar cuando utilizamos el MongoDAO ya que la
consulta getAllDepartamentos() ya devuelve los departamentos con sus empleados (que sólo tienen
el cif relleno) por lo que nos podríamos ahorrar la llamada a getEmpleadosXDpto(dptoId). Al igual
que con el Dao anterior, lo mejor es partir de una bd limpia para evitar inconsistencias (ejecutar
el script de generación de empleados y de generación de la bd mongo de departamentos).  

De momento no tenemos implementada seguridad, así que podemos acceder a este servicio sin credenciales.

Además tenemos un mapeo de /departamentos/hystrix para probar hystrix. Para ello, el método 
getAllDepartamentosConHystrix() del controlador, en vez de devolver
directamente el values() del mapa, va pidiendo al servicio de empleados cada
empleado por separado. El método getEmpleado tiene configurado hystrix para devolver un dummy empleado
en caso de error (se puede probar tirando el servicio de empleados).

Al hystrix dashboard accedemos con la url http://localhost:7777/hystrix/monitor?stream=http://localhost:7777/actuator/hystrix.stream

Se integra con los branch departamentos del cliente web y el checkout Cambiamos Post por Put
del empleados spring-boot

Algo sucede con el launch group que este proyecto no arranca, lo relanzamos y ya está